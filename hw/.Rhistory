n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("ATTAGC","ATTCAGG")
global_align("CAGT","CAG")
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(translated)
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j) {
if (i==1 && j==1) {
return()
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j), " D"))
}
# Possible directions: diagonal, left, up
diag = (score_matrix[i-1, j-1]-10 == current) | (score_matrix[i-1, j-1]+3 == current)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
print(paste(diag, left, up))
# if there is more than one valid direction to move, the shortest path should be selected
if (diag) {
return(paste(traceback_matrix(score_matrix, i-1, j-1), "X"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j), "D"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("CAGT","CAG")
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j) {
if (i==1 && j==1) {
return()
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j), " D"))
}
# Possible directions: diagonal, left, up
diag = (score_matrix[i-1, j-1]-10 == current) | (score_matrix[i-1, j-1]+3 == current)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
print(paste(diag, left, up))
# if there is more than one valid direction to move, the shortest path should be selected
if (up) {
return(paste(traceback_matrix(score_matrix, i-1, j), "D"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j-1), "X"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("CAGT","CAG")
global_align("ATTCAG","ATCTCAG")
global_align("AAAACGCAG","TTTAGCAG")
global_align("GAATTCAGTTA","GGATCGA")
global_align("AAAAAACCCCCCTTTGG","CCCCCCCTTTGGGGGG")
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(unlist(translated))
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j) {
if (i==1 && j==1) {
return()
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j), " D"))
}
# Possible directions: diagonal, left, up
diag = (score_matrix[i-1, j-1]-10 == current) | (score_matrix[i-1, j-1]+3 == current)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
print(paste(diag, left, up))
#
if (up) {
return(paste(traceback_matrix(score_matrix, i-1, j), "D"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j-1), "X"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("","")
print(translated)
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(translated)
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j) {
if (i==1 && j==1) {
return()
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j), " D"))
}
# Possible directions: diagonal, left, up
diag = (score_matrix[i-1, j-1]-10 == current) | (score_matrix[i-1, j-1]+3 == current)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
print(paste(diag, left, up))
#
if (up) {
return(paste(traceback_matrix(score_matrix, i-1, j), "D"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j-1), "X"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("","")
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(translated)
}
global_align("TAGCAG","AATACGAG")
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(unlist(translated))
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j) {
if (i==1 && j==1) {
return()
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j), " D"))
}
# Possible directions: diagonal, left, up
diag = (score_matrix[i-1, j-1]-10 == current) | (score_matrix[i-1, j-1]+3 == current)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
print(paste(diag, left, up))
#
if (up) {
return(paste(traceback_matrix(score_matrix, i-1, j), "D"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j-1), "X"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("TAGCAG","AATACGAG")
print(translated)
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(translated)
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j) {
if (i==1 && j==1) {
return()
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j), " D"))
}
# Possible directions: diagonal, left, up
diag = (score_matrix[i-1, j-1]-10 == current) | (score_matrix[i-1, j-1]+3 == current)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
print(paste(diag, left, up))
#
if (up) {
return(paste(traceback_matrix(score_matrix, i-1, j), "D"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j-1), "X"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("TAGCAG","AATACGAG")
global_align("CATTCAC","CTCGCAGC")
global_align("CACGTGATCAA","TGA")
global_align("CACGTGATCAA","AGCATCGGTTG")
