seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("UUUA","CUA")
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -8) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1, seq1, seq2)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(translated[[1]])
print(translated[[2]])
print(paste("Score:", score_matrix[m+1, n+1]))
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j, seq1, seq2) {
if (i==1 && j==1) {
return("")
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2), " D"))
}
# Possible directions: diagonal, left, up
diag = (substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] + 3) ||
(substr(seq1, i-1, i-1) != substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] - 10)
left = score_matrix[i, j-1]-8 == current
up = score_matrix[i-1, j]-8 == current
print(paste(diag, left, up))
#
if (diag) {
return(paste(traceback_matrix(score_matrix, i-1, j-1, seq1, seq2), "X"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2), "D"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("UUUA","CUA")
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1, seq1, seq2)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(translated[[1]])
print(translated[[2]])
print(paste("Score:", score_matrix[m+1, n+1]))
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j, seq1, seq2, match, mismatch, gap) {
if (i==1 && j==1) {
return("")
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2, match, mismatch, gap), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2, match, mismatch, gap), " D"))
}
# Possible directions: diagonal, left, up
diag = (substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] + 3) ||
(substr(seq1, i-1, i-1) != substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] - 10)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
print(paste(diag, left, up))
#
if (diag) {
return(paste(traceback_matrix(score_matrix, i-1, j-1, seq1, seq2, match, mismatch, gap), "X"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2, match, mismatch, gap), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2, match, mismatch, gap), "D"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("UUUA","CUA")
global_align("UUUA","CUA", gap_open = -5)
global_align("UUUA","CUAUUA", gap_open = -5)
global_align("UUUA","CUAUUA")
global_align("UUUA","CUAUUA", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("AGCT","CGT", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("AGCT","CGT", match_score=3, mismatch_score=-10, gap_open=-8)
global_align("AGCT","CGT", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("GATTACA","GCATGCT", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("GATTACA","GCATGCAT", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("AATCAGGT","CGTTTAGAC", match_score=3, mismatch_score=-10, gap_open=-3)
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1, seq1, seq2)
directions = gsub(" ", "", directions)
translated = translate_directions(directions, seq1, seq2)
print(translated[[1]])
print(translated[[2]])
print(paste("Score:", score_matrix[m+1, n+1]))
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j, seq1, seq2, match, mismatch, gap) {
if (i==1 && j==1) {
return("")
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2, match, mismatch, gap), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2, match, mismatch, gap), " D"))
}
# Possible directions: diagonal, left, up
diag = (substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] + 3) ||
(substr(seq1, i-1, i-1) != substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] - 10)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
if (diag) {
return(paste(traceback_matrix(score_matrix, i-1, j-1, seq1, seq2, match, mismatch, gap), "X"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2, match, mismatch, gap), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2, match, mismatch, gap), "D"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("AATCAGGT","CGTTTAGAC", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-6)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-5)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-4)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-3)
setwd("~/git/339n/hw")
## For this homework, use the dataset with strict quality controls.
##Data Cleaning: Remove all sequences that contain non-standard amino acids. Make sure to carefully check all columns in the data file.
df = read.csv('hw3_dataset.csv')
symbols = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")
symbols_list = paste(symbols, collapse = "")
df_cleaned = df[grepl(paste0("^[" , symbols_list, "]*$"), df$seq),]
## Print the number of rows and columns remaining after cleaning.
print(paste("Rows:", nrow(df_cleaned), "Columns:", ncol(df_cleaned)))
?set.seed
set.seed(3)
sample = sample(c(TRUE, FALSE), nrow(df_cleaned), replace = TRUE, prob = c(0.1, 0.9))
train = df_cleaned[!sample,]
test = df_cleaned[sample,]
##You will use the following symbols and states:
symbols = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")
states = c("C", "E", "H")
# Function to calculate the initial, emission, and transition probabilities
get_hmm_params = function(train, symbols, states) {
# Initialize the initial, emission, and transition probabilities
initial_probs = c(C = 0, E = 0, H = 0)
emission_probs = matrix(0, nrow = length(states), ncol = length(symbols), dimnames = list(states, symbols))
transition_probs = matrix(0, nrow = length(states), ncol = length(states), dimnames = list(states, states))
# Calculate the initial probabilities
initial_state_counts = table(substr(train$sst3, 1, 1)) # get first char of sst3
for (state in states) {
if (state %in% names(initial_state_counts)) {
initial_probs[state] = initial_state_counts[state] / nrow(train)
}
}
# Calculate the emission probabilities
for (i in 1:nrow(train)) { # go over each row and split the seq and sst3 strings
seq = strsplit(as.character(train$seq[i]), "")[[1]]
sst3 = strsplit(as.character(train$sst3[i]), "")[[1]]
for (j in 1:length(seq)) { # go over each character in the seq and sst3 strings and add to the emission_probs matrix
emission_probs[sst3[j], seq[j]] = emission_probs[sst3[j], seq[j]] + 1
}
}
emission_probs = emission_probs / rowSums(emission_probs) # convert total counts to probabilities
# Calculate the transition probabilities
for (i in 1:nrow(train)) { # go over each row and split the sst3 string
sst3 = strsplit(as.character(train$sst3[i]), "")[[1]]
for (j in 2:length(sst3)) { # go over each character in the sst3 string and add to the transition_probs matrix
transition_probs[sst3[j - 1], sst3[j]] = transition_probs[sst3[j - 1], sst3[j]] + 1
}
}
transition_probs = transition_probs / rowSums(transition_probs) # convert total counts to probabilities
return(list(initial_probs = initial_probs, emission_probs = emission_probs, transition_probs = transition_probs))
}
hmm_params = get_hmm_params(train, symbols = symbols, states = states)
print(hmm_params)
getwd()
renv::autoload()
renv::status()
## For this homework, use the dataset with strict quality controls.
##Data Cleaning: Remove all sequences that contain non-standard amino acids. Make sure to carefully check all columns in the data file.
df = read.csv('hw3_dataset.csv')
symbols = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")
symbols_list = paste(symbols, collapse = "")
df_cleaned = df[grepl(paste0("^[" , symbols_list, "]*$"), df$seq),]
## Print the number of rows and columns remaining after cleaning.
print(paste("Rows:", nrow(df_cleaned), "Columns:", ncol(df_cleaned)))
?set.seed
set.seed(3)
sample = sample(c(TRUE, FALSE), nrow(df_cleaned), replace = TRUE, prob = c(0.1, 0.9))
train = df_cleaned[!sample,]
test = df_cleaned[sample,]
##You will use the following symbols and states:
symbols = c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")
states = c("C", "E", "H")
# Function to calculate the initial, emission, and transition probabilities
get_hmm_params = function(train, symbols, states) {
# Initialize the initial, emission, and transition probabilities
initial_probs = c(C = 0, E = 0, H = 0)
emission_probs = matrix(0, nrow = length(states), ncol = length(symbols), dimnames = list(states, symbols))
transition_probs = matrix(0, nrow = length(states), ncol = length(states), dimnames = list(states, states))
# Calculate the initial probabilities
initial_state_counts = table(substr(train$sst3, 1, 1)) # get first char of sst3
for (state in states) {
if (state %in% names(initial_state_counts)) {
initial_probs[state] = initial_state_counts[state] / nrow(train)
}
}
# Calculate the emission probabilities
for (i in 1:nrow(train)) { # go over each row and split the seq and sst3 strings
seq = strsplit(as.character(train$seq[i]), "")[[1]]
sst3 = strsplit(as.character(train$sst3[i]), "")[[1]]
for (j in 1:length(seq)) { # go over each character in the seq and sst3 strings and add to the emission_probs matrix
emission_probs[sst3[j], seq[j]] = emission_probs[sst3[j], seq[j]] + 1
}
}
emission_probs = emission_probs / rowSums(emission_probs) # convert total counts to probabilities
# Calculate the transition probabilities
for (i in 1:nrow(train)) { # go over each row and split the sst3 string
sst3 = strsplit(as.character(train$sst3[i]), "")[[1]]
for (j in 2:length(sst3)) { # go over each character in the sst3 string and add to the transition_probs matrix
transition_probs[sst3[j - 1], sst3[j]] = transition_probs[sst3[j - 1], sst3[j]] + 1
}
}
transition_probs = transition_probs / rowSums(transition_probs) # convert total counts to probabilities
return(list(initial_probs = initial_probs, emission_probs = emission_probs, transition_probs = transition_probs))
}
hmm_params = get_hmm_params(train, symbols = symbols, states = states)
print(hmm_params)
?initHMM
my_hmm = initHMM(states, symbols, startProbs = hmm_params$initial_probs, transProbs = hmm_params$transition_probs, emissionProbs = hmm_params$emission_probs)
renv::install('HMM')
library(HMM)
?initHMM
my_hmm = initHMM(states, symbols, startProbs = hmm_params$initial_probs, transProbs = hmm_params$transition_probs, emissionProbs = hmm_params$emission_probs)
##  For each sequence in the test dataset (use the seq column), use the HMM to predict the most likely path of hidden states.
for (i in 1:nrow(test)) {
seq = strsplit(test$seq[i], "")
path = viterbi(my_hmm, seq[[1]])
test$predicted_sst3[i] = paste(path, collapse = "")
}
## Compare this predicted path to the actual values from the sst3 column (i.e., the true secondary structure states).
print(head(test$predicted_sst3))
print(head(test$sst3))
## For each sequence in the test set, calculate the percentage of amino acids for which the predicted secondary structure matches the actual structure.  This will give you the prediction accuracy.
for (i in 1:nrow(test)) {
test$accuracy[i] = sum(strsplit(test$predicted_sst3[i], "")[[1]] == strsplit(test$sst3[i], "")[[1]]) / nchar(test$sst3[i])
}
##Plot the distribution of these accuracy percentages.
hist(test$accuracy, main = "Prediction Accuracy Distribution", xlab = "Accuracy Percentage", ylab = "Frequency")
## Provide the following statistical measures for the distribution:Mean, Median, 90th percentile
print(paste("Mean:", mean(test$accuracy)))
print(paste("Median:", median(test$accuracy)))
print(paste("90th percentile:", quantile(test$accuracy, 0.9)))
## Q3 (4 points)  Low-Accuracy Predictions and Model Limitations
## Identify any test examples where the prediction accuracy is below 1%.
test$low_accuracy = test$accuracy < 0.05
low_accuracy_examples = test[which(test$low_accuracy == TRUE),]
R --version
getRversion()
print(hmm_params)
## Q3 (4 points)  Low-Accuracy Predictions and Model Limitations
## Identify any test examples where the prediction accuracy is below 1%.
test$low_accuracy = test$accuracy < 0.01
low_accuracy_examples = test[which(test$low_accuracy == TRUE),]
## Provide the following statistical measures for the distribution:Mean, Median, 90th percentile
print(paste("Mean:", mean(test$accuracy)))
print(paste("Median:", median(test$accuracy)))
print(paste("90th percentile:", quantile(test$accuracy, 0.9)))
print(low_accuracy_examples)
# my model did not have any instances where the accuary was below 1%
# I'll do this with instances below 5% instead to have something to analyze
test$low_accuracy = test$accuracy < 0.05
low_accuracy_examples = test[which(test$low_accuracy == TRUE),]
print(low_accuracy_examples)
## List the pdb_ids (Protein Data Bank identifiers) of these examples.
print(low_accuracy_examples$pdb_id)
## List the pdb_ids (Protein Data Bank identifiers) of these examples.
low_acc_pdb_ids = low_accuracy_examples$pdb_id
print(low_acc_pdb_ids)
## Examine the predicted and actual secondary structure sequences for these examples.
print(low_accuracy_examples[, c("seq", "sst3", "predicted_sst3")])
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(paste("Predicted:", i$predicted_sst3))
print(paste("Actual:", i$sst3))
}
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(paste("Predicted:", i$predicted_sst3))
print(paste("Actual:", i$sst3))
}
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(paste("PDB ID:", i$pdb_id))
print(paste("Predicted:", i$predicted_sst3))
print(paste("Actual:", i$sst3))
}
print(paste("PDB ID:", i[pdb_id]))
print(paste("Predicted:", i$predicted_sst3))
print(paste("Actual:", i$sst3))
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(paste("PDB ID:", i[pdb_id]))
print(paste("Predicted:", i$predicted_sst3))
print(paste("Actual:", i$sst3))
}
print(paste("PDB ID:", i'[pdb_id']))
print(paste("Predicted:", i$predicted_sst3))
print(paste("Actual:", i$sst3))
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(paste("PDB ID:", i'[pdb_id']))
print(paste("PDB ID:", i['pdb_id']))
print(paste("Predicted:", i$predicted_sst3))
print(paste("Actual:", i$sst3))
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(paste("PDB ID:", i['pdb_id']))
print(paste("Predicted:", i$predicted_sst3))
print(paste("Actual:", i$sst3))
}
print(i)
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(i)
}
print(i[["predicted_sst3"]])
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(i[["predicted_sst3"]])
}
print(i["predicted_sst3"])
## Examine the predicted and actual secondary structure sequences for these examples.
for (i in low_accuracy_examples) {
print(i["predicted_sst3"])
}
## Examine the predicted and actual secondary structure sequences for these examples.
print(low_accuracy_examples[, c("seq", "sst3", "predicted_sst3")]
## Examine the predicted and actual secondary structure sequences for these examples.
print(low_accuracy_examples[, c("seq", "sst3", "predicted_sst3")])
print(low_accuracy_examples[, c("seq", "sst3", "predicted_sst3")])
## For each of these low-accuracy examples, calculate the percentage of amino acids labeled as "E" (strand of a Î²-pleated sheet) in the actual secondary structure.
low_accuracy_examples$E_content = sapply(strsplit(low_accuracy_examples$sst3, ""), function(x) sum(x == "E") / length(x))
View(low_accuracy_examples)
## Plot the relationship between this "E" content percentage and the overall accuracy percentage of the
## HMM predictions for these examples.
plot(low_accuracy_examples$E_content, low_accuracy_examples$accuracy, main = "E Content vs. Prediction Accuracy", xlab = "E Content Percentage", ylab = "Prediction Accuracy")
## Calculate the correlation coefficient to assess the relationship between "E" content and prediction accuracy.
cor(low_accuracy_examples$E_content, low_accuracy_examples$accuracy)
# doing the same for all instances in test
test$E_content = sapply(strsplit(test$sst3, ""), function(x) sum(x == "E") / length(x))
plot(test$E_content, test$accuracy, main = "E Content vs. Prediction Accuracy", xlab = "E Content Percentage", ylab = "Prediction Accuracy")
cor(test$E_content, test$accuracy)
print(hmm_params)
