current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(diag, left, up, current)
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
}
if (current == left+3 && top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
}
if (current == up-+3 && !top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), substr(seq, j-1, j-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
}
global_align("ATTAGC","ATTCAGG")
traceback_matrix = function(score_matrix, seq, i, j, top_seq) {
if (i==1 && j==1) {
return('')
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(paste(diag, left, up, current))
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
}
if (current == left+3 && top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
}
if (current == up-+3 && !top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), substr(seq, j-1, j-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
}
global_align("ATTAGC","ATTCAGG")
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(-Inf, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
top_seq = traceback_matrix(score_matrix, seq1, m+1, n+1, T)
bottom_seq = traceback_matrix(score_matrix, seq2, m+1, n+1, F)
print(top_seq)
print(bottom_seq)
}
traceback_matrix = function(score_matrix, seq, i, j, top_seq) {
if (i==1 && j==1) {
return('')
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(paste(diag, left, up, current))
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
}
if (current == left+3 && top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
}
if (current == up-+3 && !top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), substr(seq, j-1, j-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
}
global_align("ATTAGC","ATTCAGG")
traceback_matrix = function(score_matrix, seq, i, j, top_seq) {
if (i==1 && j==1) {
return('')
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(paste(diag, left, up, current))
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
}
if (current == left+3 && top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
}
if (current == up+3 && !top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), substr(seq, j-1, j-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
}
global_align("ATTAGC","ATTCAGG")
traceback_matrix = function(score_matrix, seq, i, j, top_seq) {
if (i==1 && j==1) {
return('')
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(paste(current,diag, left, up))
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
}
if (current == left+3 && top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
}
if (current == up+3 && !top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), substr(seq, j-1, j-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
}
global_align("ATTAGC","ATTCAGG")
traceback_matrix = function(score_matrix, seq, i, j, top_seq) {
if (i==1 && j==1) {
return('')
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(paste(current,diag, left, up))
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
}
if (top_seq) {
if (current == left+3) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
}
}
if (current == up+3 && !top_seq) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), substr(seq, j-1, j-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
}
global_align("ATTAGC","ATTCAGG")
traceback_matrix = function(score_matrix, seq, i, j, top_seq) {
if (i==1 && j==1) {
return('')
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(paste(current,diag, left, up))
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
}
if (top_seq) {
if (current == left+3) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
}
} else {
if (current == up+3) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), substr(seq, j-1, j-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
}
}
global_align("ATTAGC","ATTCAGG")
traceback_matrix = function(score_matrix, seq, i, j, top_seq) {
if (i==1 && j==1) {
return('')
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(paste(current,diag, left, up))
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
} else if (top_seq) {
if (current == left+3) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
}
} else {
if (current == up+3) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), substr(seq, j-1, j-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
}
}
global_align("ATTAGC","ATTCAGG")
traceback_matrix = function(score_matrix, seq, i, j, top_seq) {
if (i==1 && j==1) {
return('')
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, seq, i-1, j, top_seq), "_"))
}
# Possible directions: diagonal, left, up
diag = score_matrix[i-1, j-1]
left = score_matrix[i, j-1]
up = score_matrix[i-1, j]
print(paste(current,diag, left, up))
if (current == diag+3 | current == diag-10) {
return(paste(traceback_matrix(score_matrix, seq, i-1, j-1, top_seq), substr(seq, i-1, i-1)))
} else if (top_seq) {
if (current == left+3) {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), substr(seq, i-1, i-1)))
} else {
return(paste(traceback_matrix(score_matrix, seq, i, j-1, top_seq), "_"))
} else if (current == up+3) {
global_align("ATTAGC","ATTCAGG")
setwd("~/git/339n/class-notes")
renv::init()
print(fib_iter(5))
# Write a function that calculates the n-th Fibonacci number iteratively
fib_iter = function(n) {
if(n == 1 | n == 2) {
return(1)
}
else {
fibo_prev = 1
fibo_current = 1
for (i in 3:n) {
fibo_next = fibo_prev + fibo_current
fibo_prev = fibo_current
fibo_current = fibo_next
}
}
return(fib_current)
}
print(fib_iter(5))
fibo_current = 1
for (i in 3:n) {
fibo_next = fibo_prev + fibo_current
fibo_prev = fibo_current
fibo_current = fibo_next
}
else {
return(fib_current)
}
print(fib_iter(5))
# Write a function that calculates the n-th Fibonacci number iteratively
fib_iter = function(n) {
if(n == 1 | n == 2) {
return(1)
}
else {
fibo_prev = 1
fibo_current = 1
for (i in 3:n) {
fibo_next = fibo_prev + fibo_current
fibo_prev = fibo_current
fibo_current = fibo_next
}
}
return(fib_current)
}
print(fib_iter(5))
# Write a function that calculates the n-th Fibonacci number iteratively
fib_iter = function(n) {
if(n == 1 | n == 2) {
return(1)
}
else {
fibo_prev = 1
fibo_current = 1
for (i in 3:n) {
fibo_next = fibo_prev + fibo_current
fibo_prev = fibo_current
fibo_current = fibo_next
}
}
return(fibo_current)
}
print(fib_iter(5))
print(fib_iter(10))
print(fib_iter(7))
print(fib_iter(8))
# Write a function that calculates the n-th Fibonacci number recursively
fib_rec = function(n) {
if (n==1 | n==2) {
return(1)
}
else {
return(fib_rec(n-1) + fib_rec(n-2))
}
}
print(fib_rec(5))
print(fib_rec(8))
print(fib_memo(5))
print(fib_memo(8))
# Write a function that calculates the n-th Fibonacci number recursively with memoization
fib_memo = function(n) {
if (is.na(fibo_nums[n])) {
# store result if the number is not already calculated
fib0_nums[n] = fib_memo(n-1) + fib_memo(n-2)
}
return(fibo_nums[n])
}
print(fib_memo(5))
print(fib_memo(8))
# Write a function that calculates the n-th Fibonacci number recursively with memoization
fib_memo = function(n) {
if (is.na(fibo_nums[n])) {
# store result if the number is not already calculated
fibo_nums[n] = fib_memo(n-1) + fib_memo(n-2)
}
return(fibo_nums[n])
}
print(fib_memo(5))
# Write a function that calculates the n-th Fibonacci number recursively with memoization
fib_memo = function(n) {
if (is.na(fibo_nums[n])) {
# store result if the number is not already calculated
fibo_nums[n] = fib_memo(n-1) + fib_memo(n-2)
}
return(fibo_nums[n])
}
print(fib_memo(5))
print(fib_memo(8))
fib_memo = function(n) {
if (is.na(fibo_nums[n])) {
# store result if the number is not already calculated
fibo_nums[n] = fib_memo(n-1) + fib_memo(n-2)
}
return(fibo_nums[n])
}
print(fib_memo(5))
print(fib_memo(8))
fibo_nums = rep(NA, 100)
fib_memo = function(n) {
if (is.na(fibo_nums[n])) {
# store result if the number is not already calculated
fibo_nums[n] = fib_memo(n-1) + fib_memo(n-2)
}
return(fibo_nums[n])
}
print(fib_memo(5))
print(fib_memo(8))
fibo_nums = c()
fibo_nums[1] = 1
fibo_nums[2] = 1
fib_memo = function(n) {
if (is.na(fibo_nums[n])) {
# store result if the number is not already calculated
fibo_nums[n] = fib_memo(n-1) + fib_memo(n-2)
}
return(fibo_nums[n])
}
print(fib_memo(5))
print(fib_memo(8))
fibo_nums = c()
fibo_nums[1] = 1
fibo_nums[2] = 1
fib_memo = function(n) {
if (is.na(fibo_nums[n])) {
# store result if the number is not already calculated
fibo_nums[n] = fib_memo(n-1) + fib_memo(n-2)
}
return(fibo_nums[n])
}
print(fib_memo(5))
print(fib_memo(8))
fibo_nums = numeric(0)
fibo_nums[1] = 1
fibo_nums[2] = 1
fib_memo = function(n) {
if (is.na(fibo_nums[n])) {
# store result if the number is not already calculated
fibo_nums[n] = fib_memo(n-1) + fib_memo(n-2)
}
return(fibo_nums[n])
}
print(fib_memo(5))
print(fib_memo(8))
# Sequence Alignments
# Recursive approach to compute the number of alignments between sequences of length m and n
num_alignments = function (n, m) {
if (n==0) {return(1)}
if (m==0) {return(1)}
return(num_alignments(n-1, m) + num_alignments(n, m-1) + num_alignments(n-1, m-1))
}
print(num_alignments(2, 2))
print(num_alignments(3, 3))
# Combinatorial formula
closed_formula = function(m, n) {
total_alignment = 0
for (k in 0:min(n,m)) {
total_alignments = total_alignments + 2^k * choose(m, k) * choose(n*k)
}
return(total_alignments)
}
closed_formula(3, 3)
# Combinatorial formula
closed_formula = function(m, n) {
total_alignments = 0
for (k in 0:min(n,m)) {
total_alignments = total_alignments + 2^k * choose(m, k) * choose(n*k)
}
return(total_alignments)
}
closed_formula(3, 3)
# Combinatorial formula
closed_formula = function(m, n) {
total_alignments = 0
for (k in 0:min(n,m)) {
total_alignments = total_alignments + 2^k * choose(m, k) * choose(n, k)
}
return(total_alignments)
}
closed_formula(3, 3)
print(num_alignments(3, 3))
