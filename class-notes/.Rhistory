} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("UUUA","CUA")
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -8) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1, seq1, seq2)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(translated[[1]])
print(translated[[2]])
print(paste("Score:", score_matrix[m+1, n+1]))
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j, seq1, seq2) {
if (i==1 && j==1) {
return("")
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2), " D"))
}
# Possible directions: diagonal, left, up
diag = (substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] + 3) ||
(substr(seq1, i-1, i-1) != substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] - 10)
left = score_matrix[i, j-1]-8 == current
up = score_matrix[i-1, j]-8 == current
print(paste(diag, left, up))
#
if (diag) {
return(paste(traceback_matrix(score_matrix, i-1, j-1, seq1, seq2), "X"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2), "D"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("UUUA","CUA")
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
print(score_matrix)
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1, seq1, seq2)
directions = gsub(" ", "", directions)
print(directions)
translated = translate_directions(directions, seq1, seq2)
print(translated[[1]])
print(translated[[2]])
print(paste("Score:", score_matrix[m+1, n+1]))
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j, seq1, seq2, match, mismatch, gap) {
if (i==1 && j==1) {
return("")
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2, match, mismatch, gap), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2, match, mismatch, gap), " D"))
}
# Possible directions: diagonal, left, up
diag = (substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] + 3) ||
(substr(seq1, i-1, i-1) != substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] - 10)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
print(paste(diag, left, up))
#
if (diag) {
return(paste(traceback_matrix(score_matrix, i-1, j-1, seq1, seq2, match, mismatch, gap), "X"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2, match, mismatch, gap), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2, match, mismatch, gap), "D"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("UUUA","CUA")
global_align("UUUA","CUA", gap_open = -5)
global_align("UUUA","CUAUUA", gap_open = -5)
global_align("UUUA","CUAUUA")
global_align("UUUA","CUAUUA", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("AGCT","CGT", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("AGCT","CGT", match_score=3, mismatch_score=-10, gap_open=-8)
global_align("AGCT","CGT", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("GATTACA","GCATGCT", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("GATTACA","GCATGCAT", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("AATCAGGT","CGTTTAGAC", match_score=3, mismatch_score=-10, gap_open=-3)
global_align = function(seq1, seq2, match_score = 3, mismatch_score = -10, gap_open = -3) {
m = nchar(seq1)
n = nchar(seq2)
score_matrix = matrix(0, nrow = m+1, ncol = n+1)
# fill out the matrix
for (i in 1:(m+1)) {
for (j in 1:(n+1)) {
if (i == 1) {
score_matrix[i,j] = gap_open * (j-1)
} else if (j == 1) {
score_matrix[i, j] = gap_open * (i-1)
} else {
match = score_matrix[i-1, j-1] + ifelse(substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1), match_score, mismatch_score)
gap_right = score_matrix[i, j-1] + gap_open
gap_down = score_matrix[i-1, j] + gap_open
score_matrix[i, j] = max(match, gap_right, gap_down)
}
}
}
# trace the matrix back
directions = traceback_matrix(score_matrix, m+1, n+1, seq1, seq2)
directions = gsub(" ", "", directions)
translated = translate_directions(directions, seq1, seq2)
print(translated[[1]])
print(translated[[2]])
print(paste("Score:", score_matrix[m+1, n+1]))
}
# Recursively trace back the matrix and return a string of the directions to take
traceback_matrix = function(score_matrix, i, j, seq1, seq2, match, mismatch, gap) {
if (i==1 && j==1) {
return("")
}
current = score_matrix[i, j]
if (i == 1) {
# Only possible to come from the left
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2, match, mismatch, gap), " L"))
} else if (j == 1) {
# Only possible to come from above
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2, match, mismatch, gap), " D"))
}
# Possible directions: diagonal, left, up
diag = (substr(seq1, i-1, i-1) == substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] + 3) ||
(substr(seq1, i-1, i-1) != substr(seq2, j-1, j-1) && current == score_matrix[i-1, j-1] - 10)
left = score_matrix[i, j-1]-3 == current
up = score_matrix[i-1, j]-3 == current
if (diag) {
return(paste(traceback_matrix(score_matrix, i-1, j-1, seq1, seq2, match, mismatch, gap), "X"))
} else if (left) {
return(paste(traceback_matrix(score_matrix, i, j-1, seq1, seq2, match, mismatch, gap), "L"))
} else {
return(paste(traceback_matrix(score_matrix, i-1, j, seq1, seq2, match, mismatch, gap), "D"))
}
}
#translate directions to alignment
translate_directions = function(directions, seq1, seq2) {
seq1_aligned = ""
seq2_aligned = ""
i = 1
n = 1
directions = unlist(strsplit(directions, ""))
for (direction in directions) {
if (direction == "X") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
i = i + 1
n = n + 1
} else if (direction == "L") {
seq1_aligned = paste(seq1_aligned, "_", sep="")
seq2_aligned = paste(seq2_aligned, substr(seq2, n, n), sep="")
n = n + 1
} else if (direction == "D") {
seq1_aligned = paste(seq1_aligned, substr(seq1, i, i), sep="")
seq2_aligned = paste(seq2_aligned, "_", sep="")
i = i + 1
}
}
return(list(seq1_aligned, seq2_aligned))
}
global_align("AATCAGGT","CGTTTAGAC", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-6)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-5)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-4)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-3)
global_align("TGCATC","CGTATC", match_score=3, mismatch_score=-10, gap_open=-3)
setwd("~/git/339n/class-notes")
# States and observables
states = ("sunny", "rainy")
# States and observables
states = c("sunny", "rainy")
observables = c("paint", "clean", "shop", "bike")
# Initial  and transition probabilities
initProbs = c(0.6, 0.4)
transProbs = matrix(c(0.8, 0.4, 0.2, 0.6), nrow=2, byrow=TRUE)
# Emission probabilities
emissionProbs = matrix(c(0.4, 0.1, 0.2, 0.3, 0.45, 0.2, 0.05), ncol=4, byrow=TRUE)
# Emission probabilities
emissionProbs = matrix(c(0.4, 0.1, 0.2, 0.3, 0.3, 0.45, 0.2, 0.05), ncol=4, byrow=TRUE)
emissionProbs
transProbs
initProbs
setwd("~/git/339n/class-notes")
obsMapped
# Observations
obsSeq = c("paint", "clean", "shop", "bike")
obsMapped - list('paint'=1, 'clean'=2, 'shop'=3, 'bike'=4)
# Observations
obsSeq = c("paint", "clean", "shop", "bike")
obsMapped = list('paint'=1, 'clean'=2, 'shop'=3, 'bike'=4)
obsMapped
str(obsMapped)
fwdProbTbl = function(obsSeq) {
fwdProb = matrix(0, nrow=length(states), ncol=length(obsSeq))
# Initialization
for (i in 1:length(states)) {
fwdProb[i, 1] = initProbs[i] * emissionProbs[i, obsMapped[[obsSeq[1]]]]
}
# Recursion
for (t in 2:length(obsSeq)) {
for (i in 1:length(states)) {
fwdProb[i, t] = sum(fwdProb[, t-1] * transProbs[, i]) * emissionProbs[i, obsMapped[[obsSeq[t]]]]
}
}
return(fwdProb)
}
fwdProb = fwdProbTbl(obsSeq)
fwdProb
}
fwdProb = fwdProbTbl(obsSeq)
fwdProb
}
fwdProbTbl = function(obsSeq) {
# Initialization
for (i in 1:length(states)) {
fwdProbMatrix[i, 1] = initProbs[i] * emissionProbs[i, obsMapped[[obsSeq[1]]]]
}
fwdProbTbl = function(obsSeq) {
fwdProbMatrix = matrix(0, nrow=length(states), ncol=length(obsSeq))
# Initialization
for (i in 1:length(states)) {
fwdProbMatrix[i, 1] = initProbs[i] * emissionProbs[i, obsMapped[[obsSeq[1]]]]
}
# Fill out the table
for (t in 2:length(obsSeq)) {
for (s in 1:length(states)) {
fwdProbMatrix[s, t] = sum(fwdProbMatrix[, t-1] * transProbs[, s]) * emissionProbs[s, obsMapped[[obsSeq[t]]]]
}
}
return(fwdProbMatrix, sum(fwdProbMatrix[, length(obsSeq)])
}
fwdProbTbl = function(obsSeq) {
fwdProbMatrix = matrix(0, nrow=length(states), ncol=length(obsSeq))
# Initialization
for (i in 1:length(states)) {
fwdProbMatrix[i, 1] = initProbs[i] * emissionProbs[i, obsMapped[[obsSeq[1]]]]
}
# Fill out the table
for (t in 2:length(obsSeq)) {
for (s in 1:length(states)) {
fwdProbMatrix[s, t] = sum(fwdProbMatrix[, t-1] * transProbs[, s]) * emissionProbs[s, obsMapped[[obsSeq[t]]]]
}
}
return(fwdProbMatrix, sum(fwdProbMatrix[, length(obsSeq)]))
}
fwdProb = fwdProbTbl(obsSeq)
fwdProb
fwdProbTbl = function(obsSeq) {
fwdProbMatrix = matrix(0, nrow=length(states), ncol=length(obsSeq))
# Initialization
for (i in 1:length(states)) {
fwdProbMatrix[i, 1] = initProbs[i] * emissionProbs[i, obsMapped[[obsSeq[1]]]]
}
# Fill out the table
for (t in 2:length(obsSeq)) {
for (s in 1:length(states)) {
fwdProbMatrix[s, t] = sum(fwdProbMatrix[, t-1] * transProbs[, s]) * emissionProbs[s, obsMapped[[obsSeq[t]]]]
}
}
return(c(fwdProbMatrix, sum(fwdProbMatrix[, length(obsSeq)])))
}
fwdProb = fwdProbTbl(obsSeq)
fwdProb
fwdProbTbl = function(obsSeq) {
fwdProbMatrix = matrix(0, nrow=length(states), ncol=length(obsSeq))
# Initialization
for (i in 1:length(states)) {
fwdProbMatrix[i, 1] = initProbs[i] * emissionProbs[i, obsMapped[[obsSeq[1]]]]
}
# Fill out the table
for (t in 2:length(obsSeq)) {
for (s in 1:length(states)) {
fwdProbMatrix[s, t] = sum(fwdProbMatrix[, t-1] * transProbs[, s]) * emissionProbs[s, obsMapped[[obsSeq[t]]]]
}
}
return(list(fwdProbMatrix, sum(fwdProbMatrix[, length(obsSeq)])))
}
fwdProb = fwdProbTbl(obsSeq)
fwdProb
# Viterbi algorithm
viterbi = function(obsSeq) {
R = length(obsSeq)
N = length(states)
# create matricies
vProbMatrix = matrix(0, nrow=N, ncol=R)
vPathMatrix = matrix(0, nrow=N, ncol=R)
# Initialization
vProbMatrix[, 1] = initProbs * emissionProbs[, obsMapped[[obsSeq[1]]]]
for (t in 2:R) {
for (s in 1:N) {
tmp = vProbMatrix[, t-1] * transProbs[, s]
vProbMatrix[s, t] = max(tmp) * emissionProbs[s, obsMapped[[obsSeq[t]]]]
vPathMatrix[s, t] = which.max(tmp)
}
}
optimalPath  = numeric(R)
optimalPath[R] = which.max(vProbMatrix[, R])
for (t in (R-1):1) {
optimalPath[t] = vPathMatrix[optimalPath[t+1], t+1]
}
names(optimalPath) = 1:R
return(states[optimalPath])
}
viterbi(obsSeq)
# Viterbi algorithm
viterbi = function(obsSeq) {
R = length(obsSeq)
N = length(states)
# create matricies
vProbMatrix = matrix(0, nrow=N, ncol=R)
vPathMatrix = matrix(0, nrow=N, ncol=R)
# Initialization
vProbMatrix[, 1] = initProbs * emissionProbs[, obsMapped[[obsSeq[1]]]]
for (t in 2:R) {
for (s in 1:N) {
tmp = vProbMatrix[, t-1] * transProbs[, s]
vProbMatrix[s, t] = max(tmp) * emissionProbs[s, obsMapped[[obsSeq[t]]]]
vPathMatrix[s, t] = which.max(tmp)
}
}
optimalPath  = numeric(R)
optimalPath[R] = which.max(vProbMatrix[, R])
for (t in (R-1):1) {
optimalPath[t] = vPathMatrix[optimalPath[t+1], t+1]
}
names(optimalPath) = 1:R
return(list(states[optimalPath], vProbMatrix, vPathMatrix))
}
viterbi(obsSeq)
renv::autoload()
# Using Libraries
install.packages("HMM")
library(HMM)
States and observables
# States and observables
states = c("sunny", "rainy")
observables = c("paint", "clean", "shop", "bike")
# Initial  and transition probabilities
initProbs = c(0.6, 0.4)
transProbs = matrix(c(0.8, 0.4, 0.2, 0.6), nrow=2, byrow=TRUE)
# Emission probabilities
emissionProbs = matrix(c(0.4, 0.1, 0.2, 0.3, 0.3, 0.45, 0.2, 0.05), ncol=4, byrow=TRUE)
# Observations
obsSeq = c("paint", "clean", "shop", "bike")
obsMapped = list('paint'=1, 'clean'=2, 'shop'=3, 'bike'=4)
fwdProbTbl = function(obsSeq) {
fwdProbMatrix = matrix(0, nrow=length(states), ncol=length(obsSeq))
# Initialization
for (i in 1:length(states)) {
fwdProbMatrix[i, 1] = initProbs[i] * emissionProbs[i, obsMapped[[obsSeq[1]]]]
}
# Fill out the table
for (t in 2:length(obsSeq)) {
for (s in 1:length(states)) {
fwdProbMatrix[s, t] = sum(fwdProbMatrix[, t-1] * transProbs[, s]) * emissionProbs[s, obsMapped[[obsSeq[t]]]]
}
}
return(list(fwdProbMatrix, sum(fwdProbMatrix[, length(obsSeq)])))
}
fwdProb = fwdProbTbl(obsSeq)
fwdProb
# Viterbi algorithm
viterbiManual = function(obsSeq) {
R = length(obsSeq)
N = length(states)
# create matricies
vProbMatrix = matrix(0, nrow=N, ncol=R)
vPathMatrix = matrix(0, nrow=N, ncol=R)
# Initialization
vProbMatrix[, 1] = initProbs * emissionProbs[, obsMapped[[obsSeq[1]]]]
for (t in 2:R) {
for (s in 1:N) {
tmp = vProbMatrix[, t-1] * transProbs[, s]
vProbMatrix[s, t] = max(tmp) * emissionProbs[s, obsMapped[[obsSeq[t]]]]
vPathMatrix[s, t] = which.max(tmp)
}
}
optimalPath  = numeric(R)
optimalPath[R] = which.max(vProbMatrix[, R])
for (t in (R-1):1) {
optimalPath[t] = vPathMatrix[optimalPath[t+1], t+1]
}
names(optimalPath) = 1:R
return(list(states[optimalPath], vProbMatrix, vPathMatrix))
}
viterbiManual(obsSeq)
# Using Libraries
install.packages("HMM")
library(HMM)
weatherHHM = initHHM(states, observables, initProbs, transProbs, emissionProbs)
weatherHHM = init.HHM(states, observables, initProbs, transProbs, emissionProbs)
weatherHHM = init_HHM(states, observables, initProbs, transProbs, emissionProbs)
weatherHHM = HHM.init(states, observables, initProbs, transProbs, emissionProbs)
